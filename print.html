<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Enshrouded Modding Documentation</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "ayu";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Enshrouded Modding Documentation</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="enshrouded-mod-loader-eml"><a class="header" href="#enshrouded-mod-loader-eml">Enshrouded Mod Loader (EML)</a></h1>
<p>EML is a lua-based mod loader and framework for the game Enshrouded.</p>
<p>As of right now, EML is in (somewhat) active development and is not yet complete.
Currently it only supports asset modifications before the game starts, but runtime modifications are planned for the future.</p>
<p>If you need help, have questions, or want to discuss modding in general, feel free to join the <a href="https://discord.gg/HKKyeMsKfW">Discord server</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="usage-instructions"><a class="header" href="#usage-instructions">Usage Instructions</a></h1>
<p>This document provides instructions on how to use the Enshrouded Mod Loader
to load and manage mods for the game Enshrouded.</p>
<p>There are currently two ways to use EML:</p>
<ol>
<li>Using the <a href="eml/usage.html#using-the-proxy-dll-recommended">Enshrouded Mod Loader Proxy DLL</a> (recommended)</li>
<li>Using the <a href="eml/usage.html#using-the-cli">Enshrouded Mod Manager CLI</a></li>
</ol>
<h2 id="using-the-proxy-dll-recommended"><a class="header" href="#using-the-proxy-dll-recommended">Using the Proxy DLL (Recommended)</a></h2>
<p>This is the recommended way to use EML as it provides a seamless experience
for loading mods directly when launching the game.</p>
<h3 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h3>
<ul>
<li>Ensure you have a legal copy of the game Enshrouded installed on your system.</li>
<li>Download the latest version of the <a href="https://github.com/Brabb3l/kfc-parser/actions/workflows/build_release.yml">dinput8.dll</a> binary.</li>
</ul>
<h3 id="installation"><a class="header" href="#installation">Installation</a></h3>
<ol>
<li>Extract the contents of the downloaded archive.</li>
<li>Copy the <code>dinput8.dll</code> file to the root directory of your Enshrouded installation.</li>
<li>Create a <code>mods</code> directory in the root directory of your Enshrouded installation
if it doesn't already exist.</li>
<li>Place the mods you want to use in the <code>mods</code> directory.</li>
<li>(Optional) Modify the <a href="eml/usage.html#emljson-configuration"><code>eml.json</code></a> configuration file.
<ul>
<li>Useful for enabling the console or export capabilities.</li>
</ul>
</li>
<li>Launch the game.</li>
</ol>
<h3 id="emljson-configuration"><a class="header" href="#emljson-configuration"><code>eml.json</code> Configuration</a></h3>
<p>This file is created automatically when you launch the game for the first time with the proxy DLL.</p>
<ul>
<li><code>enable_console</code> (boolean, default: false): If set to <code>true</code>, a console window will be opened
alongside the game for debugging purposes.</li>
<li><code>use_export_flag</code> (boolean, default: false): If set to <code>true</code>, the <code>export</code> capability will be
enabled when launching the game. This is useful if you want to let mods export stuff when using the proxy DLL.</li>
<li><code>export_directory</code> (string, default: "export"): The directory where exported files will be saved.
This path is relative to the game directory.</li>
</ul>
<h2 id="using-the-cli"><a class="header" href="#using-the-cli">Using the CLI</a></h2>
<p>This method allows you to load mods using the command line interface.
Additionally, it can also be used to run mods with the <code>export</code> capability.</p>
<h3 id="prerequisites-1"><a class="header" href="#prerequisites-1">Prerequisites</a></h3>
<ul>
<li>Ensure you have a legal copy of the game Enshrouded installed on your system.</li>
<li>Download the latest version of the <a href="https://github.com/Brabb3l/kfc-parser/actions/workflows/build_release.yml">emm.exe</a> binary.</li>
<li>A terminal or command prompt of your choice.</li>
<li>Basic knowledge of command line usage.</li>
</ul>
<h3 id="loading-mods"><a class="header" href="#loading-mods">Loading Mods</a></h3>
<p>To load mods using the CLI, follow these steps:</p>
<ol>
<li>
<p>Open a terminal or command prompt.</p>
</li>
<li>
<p>Navigate to the directory where you extracted the <code>emm.exe</code> binary
(or put it in your PATH)</p>
</li>
<li>
<p>Run the following command to run the mods:</p>
<pre><code class="language-shell">emm.exe run -g &lt;game-dir&gt; [OPTIONS]
</code></pre>
<p>By default, this will only validate the mods and not actually run them.
To actually run the mods, you need to pass feature flags for the capabilities
you want to enable.</p>
<p>For example, to enable the <code>patch</code> and <code>export</code> capabilities, you would run:</p>
<pre><code class="language-shell">emm.exe run -g &lt;game-dir&gt; --export --patch
</code></pre>
</li>
<li>
<p>Launch the game.</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="development-guide"><a class="header" href="#development-guide">Development Guide</a></h1>
<p>Welcome to the EML Guide! This guide is designed to help you understand how to create mods with the latest version of EML.</p>
<p>This guide assumes you have a basic understanding of Lua programming.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="setup"><a class="header" href="#setup">Setup</a></h1>
<p>This document provides instructions on how to set up a modding environment for
the game Enshrouded using the Enshrouded Mod Loader (EML).</p>
<h2 id="prerequisites-2"><a class="header" href="#prerequisites-2">Prerequisites</a></h2>
<ul>
<li>Ensure you have a legal copy of the game Enshrouded installed on your system.</li>
<li>Download the latest version of the Enshrouded Mod Manager CLI from <a href="https://github.com/Brabb3l/kfc-parser/actions/workflows/build_release.yml">here</a>.</li>
<li>A text editor or IDE of your choice, preferably with <a href="https://luals.github.io/">lua_ls</a> (e.g., Visual Studio Code).</li>
<li>Basic knowledge of Lua programming.</li>
</ul>
<h2 id="creating-a-mod"><a class="header" href="#creating-a-mod">Creating a Mod</a></h2>
<p>The mod manager cli can be used to create a new mod template.</p>
<pre><code class="language-bash">emm.exe create -g &lt;game-dir&gt;
</code></pre>
<p>You will be prompted to enter a few details about your mod which will be placed
within the <code>mod.json</code> <a href="eml/develop/setup.html#mod-manifest">manifest file</a>.</p>
<p>After the command completes, a new directory named after your mod id will be
created in the mods directory of your game installation.
It will also generate definition files for the Lua language server to provide
autocompletion and type checking. They are located in <code>&lt;game-dir&gt;/.cache/lua</code>.</p>
<h3 id="mod-structure"><a class="header" href="#mod-structure">Mod Structure</a></h3>
<pre><code>&lt;mod-id&gt;/
├── mod.json
├── README.md
├── .luarc.json
└── src/
    └── mod.lua
</code></pre>
<ul>
<li><code>mod.json</code>: The manifest file containing metadata about your mod.</li>
<li><code>README.md</code>: A markdown file where you can provide a detailed description of your mod.</li>
<li><code>.luarc.json</code>: Configuration file for the Lua language server.
If you don't use lua_ls or use another language server, you can safely delete this file.</li>
<li><code>src/mod.lua</code>: The main Lua script file where you will write your mod's code</li>
</ul>
<h3 id="mod-manifest"><a class="header" href="#mod-manifest">Mod Manifest</a></h3>
<p>The <code>mod.json</code> file contains metadata about your mod and is essential for EML to
recognize and load it. Below is a detailed explanation of each field in the manifest:</p>
<ul>
<li>
<p><code>id</code> (string, required): A <strong>unique</strong> identifier for your mod. The id may only
contain lowercase letters, numbers, hyphens (<code>-</code>), and underscores (<code>_</code>).
It must start with a letter.</p>
</li>
<li>
<p><code>name</code> (string, required): The display name of your mod.
This is what users will see in the mod manager.</p>
</li>
<li>
<p><code>version</code> (string, required): The version of your mod, following <a href="https://semver.org/">semantic versioning</a>.</p>
</li>
<li>
<p><code>capabilities</code> (string list, required): A list of capabilities that your mod requires.
Valid capabilities include:</p>
<ul>
<li><code>patch</code> (lua): Allows the mod to patch game data.</li>
<li><code>export</code> (lua): Allows the mod to export arbitrary data into an export directory.</li>
<li><code>runtime</code> (WIP): Allows the mod to run code at runtime.</li>
</ul>
</li>
<li>
<p><code>description</code> (string, optional): A brief description of what your mod does.
A detailed description can be provided in a separate <code>README.md</code> file.</p>
</li>
<li>
<p><code>authors</code> (string list, optional): A list of authors who contributed to the mod.</p>
</li>
<li>
<p><code>license</code> (string, optional): The license under which your mod is released (e.g., MIT, GPL-3.0).
You may also include a <code>LICENSE</code> file in your mod directory.</p>
</li>
<li>
<p><code>icon</code> (string, optional): Path to an icon file (e.g., <code>icon.png</code>) that represents your mod.
This icon will be displayed in the mod manager.</p>
</li>
<li>
<p><code>dependencies</code> (WIP): A list of other mods that your mod depends on.</p>
</li>
</ul>
<h2 id="writing-your-mod"><a class="header" href="#writing-your-mod">Writing Your Mod</a></h2>
<p>The main script file for your mod is located at <code>src/mod.lua</code>. This is the
entry point for your mod's code.</p>
<p>Refer to the definition files in <code>&lt;game-dir&gt;/.cache/lua</code> for available
functions and types provided by EML and the game or check the examples
in the <code>examples</code> directory of the repository.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h1>
<p>Before you begin, make sure to setup your development environment as described <a href="eml/develop/./setup.html">here</a>.</p>
<p>This guide only covers the <code>patch</code> and <code>export</code> capabilities. The <code>runtime</code> capability is still a work in progress and cannot be used yet.</p>
<h2 id="hello-world"><a class="header" href="#hello-world">Hello World</a></h2>
<p>Now that you have your environment set up, you should see a <code>mod.lua</code> file in the <code>src</code> directory of your mod.
By default it contains a simple Hello World example like this:</p>
<pre><code class="language-lua">print("Hello from the default mod!")
</code></pre>
<p>To run your mod refer to the <a href="eml/develop/../usage.html">usage guide</a>.
As soon as you run EML either via the CLI or the proxy DLL, you should see the message in the console output.<br />
To see a console window when using the proxy DLL, you need to enable it in the <code>eml.json</code> configuration file as described <a href="eml/develop/../usage.html#emljson-configuration">here</a>.</p>
<h2 id="definition-files"><a class="header" href="#definition-files">Definition Files</a></h2>
<p>As soon as you run EML for the first time, it will generate definition files for the Lua language server to provide autocompletion and type checking,
but they may also be used to just lookup available functions and types (especially for the game data structures).
When either the game or EML is updated, it will regenerate the definition files on the next run to ensure they are up to date.</p>
<p>These files are located in the <code>.cache/lua</code> directory of your game installation and there are currently two sets of definition files:</p>
<ul>
<li><code>base.lua</code>: Contains definitions (including documentation) for the EML API.</li>
<li><code>types.lua</code>: Contains auto generated type definitions for game data structures.</li>
</ul>
<p>If you generated a new mod using the CLI, it will also create a <code>.luarc.json</code> file in your mod directory to configure the Lua language server to use these definition files.
If you want to develop your mod in a different directory, make sure to adjust the paths in the <code>.luarc.json</code> file accordingly or else you won't get any autocompletion or type checking.</p>
<h2 id="eml-api-structure"><a class="header" href="#eml-api-structure">EML API Structure</a></h2>
<p>The EML API is divided into several globally accessable modules.</p>
<p>The most important ones are:</p>
<ul>
<li><code>game</code>: The main module to access and modify game data and assets.</li>
<li><code>loader</code>: Used to access information about the mod loader and loaded mods.
For example, you can check which mods are currently loaded or what capabilities are enabled.</li>
<li><code>buffer</code>: Provides a buffer type to work with binary data.
Since content assets are stored in an abitrary binary format, this module is essential for reading and modifying them.
There are also some modules (more coming soon) that do the parsing for you, like the <code>image</code> module for reading and writing images.</li>
</ul>
<p>Helpful modules when working with game assets:</p>
<ul>
<li><code>image</code>: A module for reading and writing images in various formats.
It provides an image type that can be used to manipulate image data.
You can convert game textures to PNG (or some other format) and vice versa.</li>
<li><code>integer</code>: Provides functions for integers of various sizes.
There are a lot of game data structures that use fixed size integers (e.g., <code>u8</code>, <code>u16</code>, etc.) and this module provides functions to work with them more comfortably.
For example, adding two <code>u8</code> values together while ensuring the result is still a <code>u8</code>.
If you're unfamiliar with these types, see the <a href="eml/develop/getting_started.html#type-aliases">Type Aliases</a> section below.</li>
<li><code>hasher</code>: Provides functions to compute hashes using various algorithms that are used by the game.
This is mainly useful when working with game assets, as they are often identified by their hash values.
There is also the <code>game.guid.hash</code> function which computes the hash of a GUID.</li>
</ul>
<p>Other useful modules include:</p>
<ul>
<li><code>io</code>: Provides functions for file system operations.
This is especially useful when using the <code>export</code> capability to save data to the export directory.
All operations are confined to either the <code>export</code> directory or the mod's own directory to prevent mods from accessing arbitrary files on the user's system.</li>
</ul>
<p>For more detailed information about the available modules and their functions, refer to the <a href="eml/develop/../api/index.html">API Reference</a>.</p>
<h3 id="type-aliases"><a class="header" href="#type-aliases">Type Aliases</a></h3>
<p>If you have already looked at the definition files, you may have noticed that there are a lot of these <code>u8</code>, <code>i32</code>, <code>f32</code>, etc. types.
These are type aliases for fixed size integers and floating point numbers.</p>
<p>You should always make sure that the values match the boundaries of the specified type, or else it will raise an error.
For example, a <code>u8</code> can only hold values from <code>0</code> to <code>255</code>, so trying to assign a value of <code>300</code> to a <code>u8</code> variable will result in an error.</p>
<p>The naming convention for these integer types is as follows:</p>
<ul>
<li><code>u</code>: Unsigned integer followed by the number of bits (e.g., <code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code>).</li>
<li><code>i</code>: Signed integer followed by the number of bits (e.g., <code>i8</code>, <code>i16</code>, <code>i32</code>, <code>i64</code>).</li>
<li><code>f</code>: Floating point number followed by the number of bits (e.g., <code>f16</code>, <code>f32</code>, <code>f64</code>).</li>
</ul>
<h2 id="accessing-game-data"><a class="header" href="#accessing-game-data">Accessing Game Data</a></h2>
<p>To access game data, you will primarily use the <code>game.assets</code> module.
But before we dive into the details, let's first understand how game data is organized.</p>
<h3 id="game-data"><a class="header" href="#game-data">Game Data</a></h3>
<p>There are two distinct types of game data:</p>
<ul>
<li>
<p><strong>Resources</strong>: These are rather small data files that contain typed binary data.
They are referenced by a GUID, a qualified type name and a part index.
The part index of a resource is used to distinguish between multiple resources with the same guid and type that belong together.
The way how part indices are used is specific to the type of resource.
For example, the voxel chunks of a scene are made up of multiple parts where all have the same type and guid, but have different part indices that specify their position.</p>
<p>They are provided as lua table-like userdata objects.
The structure of these objects is defined in the <code>types.lua</code> definition file.</p>
</li>
<li>
<p><strong>Content Assets</strong>: These are blobs that contain arbitrary binary data like images, audio, models, voxels, etc.
They are always referenced by resources via a field with the <code>keen::ContentHash</code> type.
Content assets are not parsed by EML, but instead provided as raw binary data as a <a href="eml/develop/../api/buffer.html"><code>Buffer</code></a> object.
There are also some helper modules like the <code>image</code> module to work with specific content types.</p>
</li>
</ul>
<h3 id="accessing-resources"><a class="header" href="#accessing-resources">Accessing Resources</a></h3>
<p>To access resources, you can use one of the <code>game.assets.get_resource*</code> functions.</p>
<p>If you know the exact guid, type and part index of a resource, you can use the <code>game.assets.get_resource</code> function like this:</p>
<pre><code class="language-lua">local game_scene = game.assets.get_resource("509feadb-4c60-425f-9c7c-deeefd9b6920", "keen::SceneResource", 0)

print("Guid: " .. game_scene.guid)
print("Type: " .. game_scene.type)
print("Part Index: " .. game_scene.part_index)
print("Data: " .. tostring(game_scene.data))
</code></pre>
<p>As you can see, it doesn't return the actual data directly, but instead a <code>Resource</code> object that contains some metadata about the resource (like its guid, type, part index, etc.) and the actual data is stored in the <code>data</code> field of the resource object.</p>
<p><strong>Note:</strong> The <code>Resource</code> object can be assigned everywhere where a <code>Guid</code> or <code>ObjectReference</code> is expected, so you can pass it directly to functions and fields that expect these types without having to extract the guid manually.</p>
<p>But there are also cases where you don't know the exact guid or type of a resource or are just unsure if it changes between game versions.
In these cases, you can use the either <code>game.assets.get_resources_by_type</code> or <code>game.assets.get_all_resources</code> functions to get a list of resources that match certain criteria.</p>
<p>As an example, to get all resources of a certain type, you can use the <code>game.assets.get_resources_by_type</code> function like this:</p>
<pre><code class="language-lua">local items = game.assets.get_resources_by_type("keen::ItemInfo")

for _, item in ipairs(items) do
    local item_data = item.data  -- Access the actual data of the resource

    print(item_data.itemId.value, item_data.debugName)
end
</code></pre>
<p>And if you don't know what types of resources are available, you can use the <code>game.assets.get_resource_types</code> function to get a list of all available resource types.
It is primarily useful for exploration and debugging purposes.</p>
<pre><code class="language-lua">local resource_types = game.assets.get_resource_types()

for _, resource_type in ipairs(resource_types) do
    print(resource_type)
end
</code></pre>
<p>As a last resort, there is also the <code>game.assets.get_all_resources</code> function that returns all resources in the game.
It is not recommended to use this function to filter resources by type or guid, as it is less efficient than using the other functions.</p>
<h3 id="modifying-resources"><a class="header" href="#modifying-resources">Modifying Resources</a></h3>
<p>To modify game data, you can simply change the fields of the resource's <code>data</code> object or the <code>data</code> field itself to overwrite the entire resource.
Since resources are provided as lua table-like userdata objects, you can access and modify their fields just like you would with a regular lua table.
Modifications to resources are checked for validity, so make sure to only assign valid values to fields.
If you try to assign an invalid value, it will raise an error.</p>
<p><strong>Important:</strong> If you assign a reference value (i.e., a table or a userdata) to a field, it will create a deep copy of the value.
So subsequent modifications to the original value will <strong>not</strong> affect the resource's data.</p>
<h2 id="creating-a-simple-patch"><a class="header" href="#creating-a-simple-patch">Creating a Simple Patch</a></h2>
<p>Now that you have a basic understanding of how to set up your environment and run your mod, let's create a simple patch that modifies some game data.
Open the <code>mod.lua</code> file in your mod's <code>src</code> directory and replace the existing code with the following:</p>
<pre><code class="language-lua">---@type keen.BalancingTable
local BalancingTable = game.assets.get_resources_by_type("keen::BalancingTable")[1].data

BalancingTable.playerBaseStamina = 500
</code></pre>
<p>The first line (the <code>---@type</code> annotation) is a type hint that tells the Lua language server what type the <code>BalancingTable</code> variable has.
This is not strictly necessary, but it helps with autocompletion and type checking.</p>
<p>The second line retrieves the first resource of type <code>keen::BalancingTable</code> and accesses its <code>data</code> field to get the actual balancing table data.</p>
<p>And in the last line, we modify the <code>playerBaseStamina</code> field to set the player's base stamina to <code>500</code>.</p>
<h2 id="exporting-data"><a class="header" href="#exporting-data">Exporting Data</a></h2>
<p>To export data from the game, you'll have to use the <code>export</code> capability.
Make sure to enable it in your <code>eml.json</code> configuration file if you're using the proxy DLL.</p>
<p>Now, let's modify our <code>mod.lua</code> file to export the string representation of the balancing table to a file.</p>
<pre><code class="language-lua">---@type keen.BalancingTable
local BalancingTable = game.assets.get_resources_by_type("keen::BalancingTable")[1].data

io.export("balancing_table.txt", tostring(BalancingTable))
</code></pre>
<p>When you run your mod now, it will create a file named <code>balancing_table.txt</code> in the <code>export</code> directory of your game installation (unless you changed it).
If you specify a subdirectory in the file name, it will create the necessary directories automatically.</p>
<p>You can also export a <a href="eml/develop/../api/buffer.html"><code>Buffer</code></a> object directly to export its binary data.</p>
<p><strong>Important:</strong> The <code>export</code> function can only write files to the <code>export</code> directory. Files that already exist will be overwritten without warning!</p>
<h2 id="next-steps"><a class="header" href="#next-steps">Next Steps</a></h2>
<p>Now that you have created a simple patch, you start looking into all the resource types that are available.
But most things have not been documented yet, so you'll need to figure stuff out by yourself what certain things do.
The best way is to just try things out and see what happens.</p>
<p>When it comes to content assets, i highly suggest exporting the binary data with the <code>export</code> capability and inspecting it with external tools such as <a href="https://github.com/WerWolv/ImHex">ImHex</a> for binary analysis.
Be aware that this requires some knowledge about binary formats and reverse engineering, so it may not be suitable for everyone.</p>
<p>Check out the <strong>References</strong> section for stuff that has already been documented.</p>
<p>Everything that has not been covered in this guide yet is documented in the <a href="eml/develop/../api/index.html">API Reference</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="api"><a class="header" href="#api">API</a></h1>
<p>This section provides detailed information about the api provided by EML including code examples and usage guidelines.</p>
<p>There is also documentation available in the definition file that is created when running EML for the first time.
In some cases, it may be more up-to-date than what is provided here.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="asset-management"><a class="header" href="#asset-management">Asset Management</a></h1>
<p>Asset management in EML is currently accessible through the <code>game.assets</code> module.
It provides functions to access and manipulate game assets before the game starts.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="resource"><a class="header" href="#resource">Resource</a></h1>
<p>These are rather small data files that contain typed binary data.
They are referenced by a GUID, a qualified type name and a part index.
The part index of a resource is used to distinguish between multiple resources with the same guid and type that belong together.
The way how part indices are used is specific to the type of resource.
For example, the voxel chunks of a scene are made up of multiple parts where all have the same type and guid, but have different part indices that specify their position.</p>
<p>They are provided as lua table-like userdata objects.
The structure of these objects is defined in the <code>types.lua</code> definition file.</p>
<h2 id="accessing-resources-1"><a class="header" href="#accessing-resources-1">Accessing Resources</a></h2>
<p>To access resources, you can use one of the <code>game.assets.get_resource*</code> functions.
Each of these functions will return either a single or a list of <a href="eml/api/assets/resource.html#resource-object"><code>Resource</code></a> objects.</p>
<p>Check <code>AssetManager</code> in the <code>base.lua</code> definition file for more information about the individual functions.</p>
<h2 id="resource-object"><a class="header" href="#resource-object">Resource Object</a></h2>
<p>Resource objects contain some metadata fields as well as the actual data of the resource stored in the <code>data</code> field.
When accessing the <code>data</code> field, it will return a typed userdata object depending on the type of the resource.
It acts like a regular lua table, but with some additional functionality.
When modifying the data of a resource (i.e., changing fields or adding/removing entries in arrays), these changes will be reflected in the resource itself.</p>
<p>It can also be assigned everywhere where a <code>Guid</code> or <code>ObjectReference</code> is expected, so you can pass it directly to functions and fields that expect these types without having to extract the guid manually.</p>
<p><strong>Important:</strong> If you assign a reference value (i.e., a table or a userdata) to a field, it will create a deep copy of the value.
So subsequent modifications to the original value will <strong>not</strong> affect the resource's data.</p>
<h2 id="creating-resources"><a class="header" href="#creating-resources">Creating Resources</a></h2>
<p>You can create new resources using the <code>game.assets.create_resource</code> function.
There are two variants of this function. One for creating a new resource with a new guid, and one for creating additional parts for a given resource.</p>
<p>The first one takes two arguments:</p>
<ul>
<li><code>value</code>: A value that is compatible with the specified type.</li>
<li><code>type</code>: The qualified type name (or a <code>Type</code> object) of the resource to create.</li>
</ul>
<p>It returns a new <a href="eml/api/assets/resource.html#resource-object"><code>Resource</code></a> object that contains the specified data with a newly generated guid and a part index of <code>0</code>.</p>
<p>The second one takes two <strong>additional</strong> arguments:</p>
<ul>
<li><code>guid</code>: The guid of the resource to create a new part for.</li>
<li><code>part_index</code>: The part index of the new resource part.</li>
</ul>
<p>As described in the documentation comment in the definition file, this function should be called after creating a new resource with the first variant to create additional parts of the same resource.
If the resulting resource is not unique (i.e., there is already a resource with the same guid, type and part index), it will raise an error.</p>
<p>Check <code>AssetManager</code> in the <code>base.lua</code> definition file for more information about these functions.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="content"><a class="header" href="#content">Content</a></h1>
<p>These are blobs that contain arbitrary binary data like images, audio, models, voxels, etc.
They are always referenced by resources via a field with the <code>keen::ContentHash</code> type.
Content assets are not parsed by EML, but instead provided as raw binary data as a <code>Buffer</code> object.
There are also some helper modules like the <code>image</code> module to work with specific content types.</p>
<h2 id="accessing-content"><a class="header" href="#accessing-content">Accessing Content</a></h2>
<p>To access content assets, you first need a <code>keen::ContentHash</code> value that references the content asset you want to access.
You can find these values in resource data structures.
But you can also just use the guid of a content asset if you know it.</p>
<p>Now, to actually get the content asset, you can use the <code>game.assets.get_content</code> function like this:</p>
<pre><code class="language-lua">local content_hash = some_resource.data.textureHash  -- Assume this is a keen::ContentHash value
local content_asset = game.assets.get_content(content_hash)

print("Guid: " .. content_asset.guid)
print("Size: " .. content_asset.size)
print("Data: " .. tostring(content_asset:read_data()))
</code></pre>
<p>This function returns a <a href="eml/api/assets/"><code>Content</code></a> object that contains some metadata about the content asset (like its guid and size) and a method to read the actual binary data as a read-only <code>Buffer</code> object.</p>
<p><strong>Note:</strong> The <code>Content</code> object can be assigned everywhere where a <code>Guid</code> or <code>keen::ContentHash</code> is expected, so you can pass it directly to functions and fields that expect these types without having to extract the guid manually.</p>
<h2 id="content-object"><a class="header" href="#content-object">Content Object</a></h2>
<p>A content object contains some metadata about the content asset such as its guid and size but also a method to read the actual binary data.
Calling the <code>read_data</code> method will return a read-only <code>Buffer</code> object that contains the binary data of the content asset.</p>
<p>In comparison to resources, content assets are immutable since content hashes are unique, so the data for a given content hash is always the same and never changes.
Because of that, you will have to instead create new content assets and update the old references.</p>
<h2 id="creating-content"><a class="header" href="#creating-content">Creating Content</a></h2>
<p>To create new content assets, you can use the <code>game.assets.create_content</code> function.
This function takes a <code>Buffer</code> object containing the binary data of the content asset and returns a new <code>Content</code> object that can be assigned to resource fields.</p>
<pre><code class="language-lua">local buf = ... -- Assume this is a Buffer object containing the binary data of the content asset
local content_asset = game.assets.create_content(buf)

print("Guid: " .. content_asset.guid)
print("Size: " .. content_asset.size)
</code></pre>
<h2 id="binary-format"><a class="header" href="#binary-format">Binary Format</a></h2>
<p>Every content asset is stored differently depending on the context where it is used.
For example, image content are referenced in <code>keen::UiTextureResource</code> which has information about the format, size, etc. of the image data.
Without it, its very hard to interpret the raw binary data of a content asset.</p>
<p>Currently, EML does only provide the <code>image</code> module as a helper to work with image content assets.
That is, because most content formats have not been figured out just yet.
So you will have to reverse engineer the binary formats on your own if you want to work with other content types.
When doing so, i highly suggest exporting the binary data with the <code>export</code> capability and inspecting it with external tools such as <a href="https://github.com/WerWolv/ImHex">ImHex</a> for binary analysis.
Be aware that this requires some knowledge about binary formats and reverse engineering, so it may not be suitable for everyone.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="loader"><a class="header" href="#loader">Loader</a></h1>
<p>The <code>loader</code> module provides information about the current environment in which the mod is currently running in.</p>
<ul>
<li><code>is_client</code>: A boolean value indicating whether the mod is running in a client environment.</li>
<li><code>is_server</code>: A boolean value indicating whether the mod is running in a server environment.</li>
<li><code>features</code>: See <a href="eml/api/loader.html#features">Features</a>.</li>
<li><code>has_mod(mod_id)</code>: Checks if a mod with the specified ID is loaded.</li>
</ul>
<h2 id="features"><a class="header" href="#features">Features</a></h2>
<p>The <code>features</code> table contains boolean flags indicating the availability of certain features in the current environment.</p>
<ul>
<li><code>patch</code>: Indicates whether data patching is supported.</li>
<li><code>export</code>: Indicates whether data exporting is supported.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="buffer"><a class="header" href="#buffer">Buffer</a></h1>
<p>A <code>Buffer</code> is a (mutable or immutable) sequence of bytes for reading and writing binary data.</p>
<p>Buffers act like a FIFO (first-in, first-out) stream where data is read from the front and written to the back.
To achieve this, it has two 0-based byte offsets:</p>
<ul>
<li><strong>head</strong>: The position where data is read from (next byte to read).</li>
<li><strong>tail</strong>: The position where data is written to (next byte to write).</li>
</ul>
<p>That means that bytes are read in the order they were written, unless you modify the <strong>head</strong> or <strong>tail</strong> positions manually.</p>
<p>Reading or writing bytes advances the respective offset by the number of bytes read or written.
If <strong>head</strong> should ever exceeds <strong>tail</strong>, a read error is raised.</p>
<p>Additionally, buffers have a <strong>capacity</strong> which is the total allocated size of the buffer in bytes.
It is automatically increased as needed when writing but the amount of growth may vary.
It is not to be confused with the actual size; it is simply the amount of space the buffer can work with without needing to reallocate memory.
The actual size is determined by the difference between <strong>tail</strong> and <strong>head</strong>.</p>
<p>Buffers are primarily used to work with raw binary data such as <a href="eml/api/./assets/content.html"><code>Content</code></a> assets.
But they may also be used to work with embedded binary data in resources.</p>
<h2 id="creating-buffers"><a class="header" href="#creating-buffers">Creating Buffers</a></h2>
<p>There are two ways to create new buffers:</p>
<ul>
<li><code>buffer.create</code>: Creates a new empty mutable buffer with an optional initial capacity.</li>
<li><code>buffer.wrap</code>: Creates a new mutable buffer from a given string.</li>
</ul>
<pre><code class="language-lua">local buf1 = buffer.create(128)  -- Create an empty buffer with an initial capacity
local buf2 = buffer.wrap("Hello, World!")  -- Create a buffer from a string
</code></pre>
<h2 id="reading-and-writing-data"><a class="header" href="#reading-and-writing-data">Reading and Writing Data</a></h2>
<p>Buffers provide various methods to read and write different types of data.
Refer to the <code>base.lua</code> definition file for a complete list of available methods.</p>
<p>Here are some examples of reading and writing data:</p>
<pre><code class="language-lua">local buf = buffer.create()  -- Create a new empty buffer

buf:write_u8(42)             -- Write a byte (0x2A)
buf:write_string("Hello")    -- Write a string ("Hello")

assert(buf:tail() == 6)      -- Tail is now at position 6
assert(buf:head() == 0)      -- Head is still at position 0
</code></pre>
<pre><code class="language-lua">local a = buf:read_u8()        -- Read a byte (0x2A)
local str = buf:read_string(5) -- Read a string ("Hello")

assert(a == 42)                -- a is 42
assert(str == "Hello")         -- str is "Hello"

assert(buf:head() == 6)        -- Head is now at position 6
assert(buf:tail() == 6)        -- Tail is still at position 6
</code></pre>
<h2 id="reading-and-writing-raw-resources"><a class="header" href="#reading-and-writing-raw-resources">Reading and Writing raw Resources</a></h2>
<p>In some cases, you may come across resources that are still in their raw binary format.
In such cases, you can use the <code>read_resource</code> and <code>write_resource</code> methods to read and write these resources directly from/to a buffer.</p>
<p>This is currently the case for translations which are resources stored as a content asset.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="image"><a class="header" href="#image">Image</a></h1>
<p>The <code>image</code> module provides functions for encoding and decoding image data in various formats.
It supports common image formats such as PNG and JPEG, but also gpu image formats like R8G8B8A8_UNORM, BCn, etc.</p>
<h2 id="decoding-images"><a class="header" href="#decoding-images">Decoding Images</a></h2>
<p>There are two separate functions to decode image data for different use cases:</p>
<ul>
<li><code>image.decode</code>: Decodes regular image data such as PNG or JPEG into an <a href="eml/api/image.html#image-object"><code>Image</code></a> object.</li>
<li><code>image.decode_texture</code>: Decodes image data in a GPU format into an <a href="eml/api/image.html#image-object"><code>Image</code></a> object.</li>
</ul>
<p>Both functions take a <a href="eml/api/./buffer.html"><code>Buffer</code></a> object containing the binary image data as input and return an <a href="eml/api/image.html#image-object"><code>Image</code></a> object representing the decoded image.
However <code>decode_texture</code> also requires the width, height, format and mip level of the image to decode it properly.</p>
<pre><code class="language-lua">local png_buffer = io.read("image.png")
local png_image = image.decode(png_buffer)

local texture_buffer = io.read("texture.dat")
local texture_image = image.decode_texture(texture_buffer, 256, 256, "R8G8B8A8_UNORM")
</code></pre>
<h2 id="encoding-images"><a class="header" href="#encoding-images">Encoding Images</a></h2>
<p>Similar to decoding, there are two separate functions to encode image data for different use cases:</p>
<ul>
<li><code>image.encode</code>: Encodes an <a href="eml/api/image.html#image-object"><code>Image</code></a> object into regular image formats such as PNG or JPEG.</li>
<li><code>image.encode_texture</code>: Encodes an <a href="eml/api/image.html#image-object"><code>Image</code></a> object into a GPU image format.</li>
</ul>
<p>Both functions take an <a href="eml/api/image.html#image-object"><code>Image</code></a> object as input and return a <a href="eml/api/./buffer.html"><code>Buffer</code></a> object containing the encoded binary image data.</p>
<p><strong>Note:</strong> Encoding to GPU formats may be a slow process depending on the format and size of the image. Especially for block-compressed formats, it may take several seconds to encode a single image.</p>
<pre><code class="language-lua">local image = ... -- Assume this is an Image object
local png_buffer = image.encode(image, "PNG")

io.export("output.png", png_buffer) -- Export the PNG image

local texture_buffer = image.encode_texture(image, "R8G8B8A8_UNORM")
</code></pre>
<h2 id="converting-images"><a class="header" href="#converting-images">Converting Images</a></h2>
<p>With encoding and decoding functions available, you can easily convert images between different formats.</p>
<p>For example, to extract a texture from a resource and convert it to a PNG image, you can do the following:</p>
<pre><code class="language-lua">local texture_resource = ... -- Assume this is a keen::UiTextureResource
local content = game.assets.get_content(texture_resource.data)

-- Decode the texture data into an Image object
local texture_image = image.decode_texture(
    content:read_data(),
    texture_resource.width,
    texture_resource.height,
    texture_resource.format
)

-- Encode the Image object into a PNG image
local png_buffer = image.encode(texture_image, "PNG")

io.export("texture.png", png_buffer) -- Export as PNG
</code></pre>
<p>This also works the other way around, so you can convert a PNG image into a GPU texture format:</p>
<pre><code class="language-lua">local png_buffer = io.read("input.png")
local image = image.decode(png_buffer)
local texture_buffer = image.encode_texture(image, "R8G8B8A8_UNORM")

local texture_resource = ... -- Assume this is a keen::UiTextureResource

texture_resource.width = image.width
texture_resource.height = image.height
texture_resource.format = "R8G8B8A8_UNORM"
texture_resource.data = game.assets.create_content(texture_buffer)
</code></pre>
<h2 id="creating-images"><a class="header" href="#creating-images">Creating Images</a></h2>
<p>You can also create new <a href="eml/api/image.html#image-object"><code>Image</code></a> objects from scratch by using the <code>image.create</code> function.
It takes the width and height of the image and returns a new empty <a href="eml/api/image.html#image-object"><code>Image</code></a> object where all pixels are initialized to transparent black.</p>
<pre><code class="language-lua">local img = image.create(128, 128)  -- Create a new 128x128 image
</code></pre>
<h2 id="image-object"><a class="header" href="#image-object">Image Object</a></h2>
<p>An <code>Image</code> object represents a 2D image with pixel data stored in RGBA format.
It provides some basic methods to manipulate the image data, such as getting and setting pixel colors.</p>
<p>Check the <code>Image</code> definition in the <code>base.lua</code> definition file for a complete list of available methods and properties.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="types"><a class="header" href="#types">Types</a></h1>
<p>The <code>game.types</code> module provides access to extracted type metadata from the game's binary.
You can use it to query information about types, their fields, inheritance relationships, etc.</p>
<p>Check <code>TypeRegistry</code> in the <code>base.lua</code> definition file for more information about the available fields and functions.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="io"><a class="header" href="#io">IO</a></h1>
<p>The <code>io</code> module provides functions for reading and exporting files and data.</p>
<p><strong>Note:</strong> All io operations (except <code>io.export</code>) are currently only supported for files within the mod's own directory.
Additionally, all operations are subject to io errors which may be raised if something goes wrong (e.g. file not found, permission denied, etc.).</p>
<h2 id="reading-files"><a class="header" href="#reading-files">Reading Files</a></h2>
<p>You can use the <code>io.read</code> or <code>io.read_to_string</code> functions to read a file and get its contents as a <a href="eml/api/./buffer.html"><code>Buffer</code></a> object or a string respectively.
This can be useful to load configurations, binary data, or any other type of file your mod needs to work with.</p>
<pre><code class="language-lua">local contents = io.read_to_string("path/to/file.txt")

-- Outputs the content of the file.
print(contents)
</code></pre>
<p><strong>Note:</strong> Reading is currently only supported for files within the mod's own directory.</p>
<h2 id="exporting-files"><a class="header" href="#exporting-files">Exporting Files</a></h2>
<p>You can use the <code>io.export</code> function to write data to a file relative to the specified export directory.</p>
<p>The <code>export</code> capability must be enabled for this function to work, otherwise an error will be raised.</p>
<pre><code class="language-lua">-- Exports "Hello, World!" to "&lt;export-dir&gt;/greetings/hello.txt"
io.export("greetings/hello.txt", "Hello, World!")
</code></pre>
<h2 id="file-system"><a class="header" href="#file-system">File System</a></h2>
<p>If you have multiple files or need to work with directories, you can use the following functions:</p>
<ul>
<li><code>io.list_files</code>: Lists all files in a given directory. (non-recursive)</li>
<li><code>io.exists</code>: Checks if a file or directory exists.</li>
<li><code>io.is_file</code>: Checks if a given path is a file.</li>
<li><code>io.is_directory</code>: Checks if a given path is a directory.</li>
</ul>
<p>There are also a few helper functions to work with file paths:</p>
<ul>
<li><code>io.name</code>: Gets the name of a file (with extension) or directory from a given path.</li>
<li><code>io.name_without_extension</code>: Gets the name of a file without its extension from a given path.</li>
<li><code>io.extension</code>: Gets the extension of a file from a given path.</li>
<li><code>io.parent</code>: Gets the parent directory of a given path or nil if there is none.</li>
<li><code>io.join</code>: Joins multiple path segments into a single path.</li>
</ul>
<p>Check the <code>base.lua</code> definition file for more information about these functions (including examples).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="utilities"><a class="header" href="#utilities">Utilities</a></h1>
<p>This section covers smaller and niche modules that provide various utility functions for different purposes.
These modules may not fit into the main categories but are still useful for mod development.</p>
<h2 id="guid-helper"><a class="header" href="#guid-helper">Guid Helper</a></h2>
<p>The <code>game.guid</code> module provides utility functions to work with GUID strings.</p>
<ul>
<li><code>hash</code>: Computes a hash value from a GUID string.</li>
<li><code>from_content_hash</code>: Converts a <code>keen::ContentHash</code> object to a GUID string.</li>
<li><code>to_content_hash</code>: Converts a GUID string to a <code>keen::ContentHash</code> object.</li>
</ul>
<h2 id="hasher"><a class="header" href="#hasher">Hasher</a></h2>
<p>The <code>hasher</code> module provides functions to compute hash values for data.</p>
<p>Currently supported hash algorithms are:</p>
<ul>
<li><code>fnv1a32</code>: FNV-1a 32-bit hash</li>
<li><code>crc32</code>: CRC-32/ISO-HDLC checksum</li>
<li><code>crc64</code>: CRC-64/ECMA-182 checksum</li>
</ul>
<h2 id="integer"><a class="header" href="#integer">Integer</a></h2>
<p>The <code>integer</code> module provides functions for working with fixed-sized integers.
It covers all standard sizes from 8-bit to 64-bit, both signed and unsigned.</p>
<p>Each type has the same set of fields:</p>
<ul>
<li><code>MAX</code>: The maximum representable value for the integer type.</li>
<li><code>MIN</code>: The minimum representable value for the integer type.</li>
<li><code>BITS</code>: The number of bits used to represent the integer type.</li>
</ul>
<p>Each type also has the following utility functions:</p>
<ul>
<li><code>parse(string)</code>: Parses a string and returns the corresponding integer value.
If the string is not a valid representation of the integer type, nil is returned.</li>
<li><code>truncate(value)</code>: Truncates the bits of a given number to fit within the bounds of the integer type.</li>
<li><code>clamp(value)</code>: Clamps a given number to fit within the bounds of the integer type.
If the number is less than <code>MIN</code>, <code>MIN</code> is returned.
If the number is greater than <code>MAX</code>, <code>MAX</code> is returned.</li>
<li><code>is_valid(value)</code>: Checks if a given number is within the bounds of the integer type.</li>
<li><code>to_string(value)</code>: Converts a given integer value to its string representation.</li>
</ul>
<p>Besides these utility functions, each type has a bunch of functions for various operations on the integer type.
I will only cover a few important things here, check the <code>base.lua</code> definition file for more information about all available functions.</p>
<p>Besides the regular arithmetic functions like <code>add</code>, <code>sub</code>, <code>mul</code>, <code>div</code>,
there is also a <code>checked</code>, <code>saturating</code>, <code>wrapping</code>, and <code>overflowing</code> variant for each arithmetic operation.</p>
<ul>
<li><code>checked_*(a, b)</code>: Performs the operation and returns nil if an overflow occurs.</li>
<li><code>saturating_*(a, b)</code>: Performs the operation and clamps the result to the bounds of the integer type if an overflow occurs.</li>
<li><code>wrapping_*(a, b)</code>: Performs the operation and wraps around the result if an overflow.
This is the default behavior for integer operations.</li>
<li><code>overflowing_*(a, b)</code>: Performs the operation and returns a tuple containing the result and a boolean indicating whether an overflow occurred.
If an overflow occurs, the result is wrapped around.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="resources"><a class="header" href="#resources">Resources</a></h1>
<p>This section covers the various resource types available in the game.</p>
<p>For content format details, check <a href="game/resource/../content/index.html">the content section</a>.
It will be updated and expanded over time as more resources are documented.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="scene"><a class="header" href="#scene">Scene</a></h1>
<p>A Scene is a container for all the game objects, lights, and other elements that make up an environment in the game.</p>
<p>Each scene is composed of multiple different objects with the <strong>same</strong> GUID (this list may not be complete):</p>
<ul>
<li><code>keen::SceneResource</code></li>
<li><code>keen::FogVoxelMappingResource</code></li>
<li><code>keen::RenderModelChunkGridResource</code></li>
<li><code>keen::RenderModelChunkModelResource</code></li>
<li><code>keen::SceneCinematicList</code></li>
<li><code>keen::SceneEntityChunkResource</code></li>
<li><code>keen::SceneRandomLootResource</code></li>
<li><code>keen::VolumetricFog3ModelResource</code></li>
<li><code>keen::VoxelTemperatureResource</code></li>
<li><code>keen::VoxelWorldChunkResource</code></li>
<li><code>keen::VoxelWorldFog3Resource</code></li>
<li><code>keen::VoxelWorldResource</code></li>
<li><code>keen::WaterChunkResource</code></li>
</ul>
<h3 id="keensceneresource"><a class="header" href="#keensceneresource"><code>keen::SceneResource</code></a></h3>
<p>This object contains mostly static information about the scene, such as models, lights, bounds, and other elements.
Check the type definition for more details.</p>
<h3 id="chunks"><a class="header" href="#chunks">Chunks</a></h3>
<p><strong>Note:</strong> This section is incomplete and may contain inaccurate information.</p>
<p>The scene contains several chunked resources that describe the terrain/fog voxels, water or entities.
There are 4 chunked resources in total:</p>
<ul>
<li><code>keen::VoxelWorldChunkResource</code>: Contains the terrain and fog voxel data.</li>
<li><code>keen::RenderModelChunkModelResource</code>: Most likely contains the low-detail model for the terrain.</li>
<li><code>keen::WaterChunkResource</code>: Contains water data.</li>
<li><code>keen::SceneEntityChunkResource</code>: Contains entities placed in the scene.</li>
</ul>
<h4 id="voxels"><a class="header" href="#voxels">Voxels</a></h4>
<p>Each chunk of voxels is stored in a <code>keen::VoxelWorldChunkResource</code> object.
And for both the terrain and fog voxels, there is a separate <code>keen::VoxelWorldResource</code> object that contains:</p>
<ul>
<li><code>type</code> (terrain or fog): Indicates whether the voxel data represents terrain or fog.</li>
<li><code>tileCount</code> (x, z): The number of <code>keen::VoxelWorldChunkResource</code> chunks in the x and z dimensions.
There is no y dimension, as the height seems to be determined by the voxel data itself.</li>
<li><code>origin</code> (x, y, z): The position of the chunk grid's origin in world space.</li>
<li><code>lowLODData</code>: Most likely a lower-resolution representation of the voxel data for rendering at a distance.</li>
<li><code>materialGuids</code> (max 256): Most likely a list of material guids used for the voxels.</li>
</ul>
<p>There are other fields, but their purpose is currently unknown. Check the type definition for more details.</p>
<p>To access the respective <code>keen::VoxelWorldChunkResource</code> objects, you will need to know the part indices of the <code>keen::VoxelWorldChunkResource</code> you want to access.
All <code>keen::VoxelWorldChunkResource</code> objects in the scene will have the same GUID,
where the part index corresponds to <code>flattened chunk coordinates + amount of chunks of previous keen::VoxelWorldResources</code>.</p>
<p>For example, if you have a terrain and fog voxel world with 2x2 chunks,
the part indices for the terrain chunks will be 0, 1, 2, and 3,
while the part indices for the fog chunks will be 4, 5, 6, and 7.</p>
<p>Now, to access the voxel data of a chunk, you will need to access the content that is referenced by the <code>highLODData</code> field in the <code>keen::VoxelWorldChunkResource</code>.
The binary format of the voxel data is currently unknown, but zeroing out the data will result in an empty chunk.</p>
<h4 id="water"><a class="header" href="#water">Water</a></h4>
<p>The water data is stored in <code>keen::WaterChunkResource</code> objects.</p>
<h4 id="entities"><a class="header" href="#entities">Entities</a></h4>
<p>The entities placed in the scene are stored in <code>keen::SceneEntityChunkResource</code> objects.
Each chunk contains a list of template references, models and entity spawns.
The amount of chunks is determined by the <code>entityChunkCount</code> (x, z) field in the <code>keen::SceneResource</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="content-1"><a class="header" href="#content-1">Content</a></h1>
<p>This section covers the various binary content formats used in the game.
It will be updated and expanded over time as more content formats are documented.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="image-1"><a class="header" href="#image-1">Image</a></h1>
<p>The game primarily uses gpu-ready packed/compressed texture formats for images.</p>
<p>A list of all supported formats can be found in the <code>keen::PixelFormat</code> enum in the type definitions.
All formats follow <a href="https://docs.vulkan.org/spec/latest/chapters/formats.html">Vulkan's Format Spec</a></p>
<p>The most commonly used formats are:</p>
<ul>
<li><code>R8G8B8A8_UNORM</code>: 32-bit RGBA format for color textures with alpha (e.g. sprites, UI elements)</li>
<li><code>BC7_SRGB_BLOCK</code>: Compressed format for color textures with optional alpha (e.g. albedo/diffuse maps)</li>
<li><code>BC5_UNORM_BLOCK</code>: Compressed format for normal maps</li>
<li><code>BC1_RGB_UNORM_BLOCK</code>: Compressed format for material parameters (e.g. roughness, metallic, ambient occlusion)</li>
<li><code>BC4_UNORM_BLOCK</code>: Compressed format for single-channel textures (e.g. masks)</li>
<li><code>BC6H_UFLOAT_BLOCK</code>: Compressed format for HDR textures (e.g. emissive maps)</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="game-file-documentation"><a class="header" href="#game-file-documentation">Game File Documentation</a></h1>
<p>The game consists of:</p>
<ul>
<li><strong>One</strong> <code>.kfc</code> file</li>
<li><strong>Multiple</strong> <code>.dat</code> files (containers). The number of <code>.dat</code> files is always a <strong>power of two</strong> and they always need to be present even if empty.</li>
</ul>
<p>There are two different kinds of assets:</p>
<ul>
<li><strong>Resource</strong>: typed binary data (type metadata defined in the <a href="game/kfc/./types.html">types section</a> and bundled inside the executable).
Resources can be referenced by <code>ObjectReference&lt;T&gt;</code> typed fields.
They are stored in the <code>.kfc</code> file (after the header) and are <strong>16-byte aligned</strong>.</li>
<li><strong>Content</strong>: opaque blobs (images, audio, models, voxels, etc.).
Content assets are referenced by resources via a <code>keen::ContentHash</code> typed field.
They are stored in the <code>.dat</code> files and are <strong>4096-byte aligned</strong>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="kfc-file-format-specification"><a class="header" href="#kfc-file-format-specification">KFC File Format Specification</a></h1>
<p>Everything is little-endian unless otherwise noted.</p>
<p>The format of resources is defined in the <a href="game/kfc/./resource.html">resource section</a>.</p>
<h2 id="header"><a class="header" href="#header">Header</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Size (bytes)</th><th>Description</th></tr></thead><tbody>
<tr><td>magic</td><td>uint32</td><td>4</td><td>File signature: <code>4B 46 43 32</code> ("KFC2")</td></tr>
<tr><td>size</td><td>uint32</td><td>4</td><td>Size in bytes of the header area.</td></tr>
<tr><td>unknown</td><td>uint32</td><td>4</td><td>Always 12</td></tr>
<tr><td>padding</td><td>uint32</td><td>4</td><td>Padding? Always 0</td></tr>
<tr><td>version</td><td>KFCLocation</td><td>8</td><td>Points to <code>uint8[count]</code> containing the version string.</td></tr>
<tr><td>containers</td><td>KFCLocation</td><td>8</td><td>Points to <a href="game/kfc/file.html#containerinfo"><code>ContainerInfo[count]</code></a> describing <code>.dat</code> files.</td></tr>
<tr><td>unused0</td><td>KFCLocation</td><td>8</td><td>Unused, always null location.</td></tr>
<tr><td>unused1</td><td>KFCLocation</td><td>8</td><td>Unused, always null location.</td></tr>
<tr><td>resource_locations</td><td>KFCLocation</td><td>8</td><td>Points to <a href="game/kfc/file.html#resourcelocation"><code>ResourceLocation[count]</code></a> describing where resources are stored within this file.</td></tr>
<tr><td>resource_indices</td><td>KFCLocation</td><td>8</td><td>Points to <code>uint32[count]</code> mapping <code>ResourceBundleEntry::index</code> to an index in <code>resource_keys</code>. See <a href="game/kfc/file.html#resource-bundles">Resource Bundles</a>.</td></tr>
<tr><td>content_buckets</td><td>KFCLocation</td><td>8</td><td>Points to <a href="game/kfc/file.html#staticmapbucket"><code>StaticMapBucket[count]</code></a> for content <a href="game/kfc/file.html#static-map">static map</a>.</td></tr>
<tr><td>content_keys</td><td>KFCLocation</td><td>8</td><td>Points to <a href="game/kfc/file.html#contenthash"><code>ContentHash[count]</code></a> for content <a href="game/kfc/file.html#static-map">static map</a>.</td></tr>
<tr><td>content_values</td><td>KFCLocation</td><td>8</td><td>Points to <a href="game/kfc/file.html#contententry"><code>ContentEntry[count]</code></a> for content <a href="game/kfc/file.html#static-map">static map</a>.</td></tr>
<tr><td>resource_buckets</td><td>KFCLocation</td><td>8</td><td>Points to <a href="game/kfc/file.html#staticmapbucket"><code>StaticMapBucket[count]</code></a> for resources <a href="game/kfc/file.html#static-map">static map</a>.</td></tr>
<tr><td>resource_keys</td><td>KFCLocation</td><td>8</td><td>Points to <a href="game/kfc/file.html#resourceid"><code>ResourceId[count]</code></a> for resources <a href="game/kfc/file.html#static-map">static map</a>.</td></tr>
<tr><td>resource_values</td><td>KFCLocation</td><td>8</td><td>Points to <a href="game/kfc/file.html#resourceentry"><code>ResourceEntry[count]</code></a> for resources <a href="game/kfc/file.html#static-map">static map</a>.</td></tr>
<tr><td>resource_bundle_buckets</td><td>KFCLocation</td><td>8</td><td>Points to <a href="game/kfc/file.html#staticmapbucket"><code>StaticMapBucket[count]</code></a> for resource bundles <a href="game/kfc/file.html#static-map">static map</a>.</td></tr>
<tr><td>resource_bundle_keys</td><td>KFCLocation</td><td>8</td><td>Points to <code>uint32[count]</code> for resource bundles <a href="game/kfc/file.html#static-map">static map</a>. (the internal hash of the resource type)</td></tr>
<tr><td>resource_bundle_values</td><td>KFCLocation</td><td>8</td><td>Points to <a href="game/kfc/file.html#resourcebundleentry"><code>ResourceBundleEntry[count]</code></a> for resource bundles <a href="game/kfc/file.html#static-map">static map</a>.</td></tr>
</tbody></table>
</div>
<p>Addtional notes:</p>
<ul>
<li><code>version</code> is a non-null-terminated ASCII string.</li>
<li><code>resource_indices.count</code> == <code>resource_keys.count</code> == <code>resource_values.count</code></li>
</ul>
<h3 id="kfclocation"><a class="header" href="#kfclocation">KFCLocation</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Size (bytes)</th><th>Description</th></tr></thead><tbody>
<tr><td>relative_offset</td><td>uint32</td><td>4</td><td>The amount of bytes between the offset of this field and the start of the data it is pointing to.</td></tr>
<tr><td>count</td><td>uint32</td><td>4</td><td>The number of entries of the type being pointed to.</td></tr>
</tbody></table>
</div>
<p>To get the absolute file offset of the data, add <code>relative_offset</code> to the file offset of the <code>relative_offset</code> field itself.
For example, if the <code>relative_offset</code> field is at file offset 0x20 and its value is 0x100, the data starts at file offset 0x120.</p>
<h3 id="containerinfo"><a class="header" href="#containerinfo">ContainerInfo</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Size (bytes)</th><th>Description</th></tr></thead><tbody>
<tr><td>size</td><td>uint64</td><td>8</td><td>Total size of the <code>.dat</code> container file in bytes.</td></tr>
<tr><td>count</td><td>uint64</td><td>8</td><td>Number of contents in this container.</td></tr>
</tbody></table>
</div>
<p>While the size is a <code>uint64</code>, <a href="game/kfc/file.html#contententry">ContentEntry</a> uses a <code>uint32</code> for the offset and size of each content,
so no single content can be larger than 4 GiB.</p>
<h3 id="resourcelocation"><a class="header" href="#resourcelocation">ResourceLocation</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Size (bytes)</th><th>Description</th></tr></thead><tbody>
<tr><td>offset</td><td>uint32</td><td>4</td><td>Offset to where the resources start in this file. (absolute)</td></tr>
<tr><td>size</td><td>uint32</td><td>4</td><td>Total size of all resources in bytes.</td></tr>
<tr><td>count</td><td>uint32</td><td>4</td><td>Number of resources.</td></tr>
</tbody></table>
</div>
<p>There is currently always exactly one <code>ResourceLocation</code> entry.
It may work with multiple entries, but this has not been tested yet.</p>
<h3 id="staticmapbucket"><a class="header" href="#staticmapbucket">StaticMapBucket</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Size (bytes)</th><th>Description</th></tr></thead><tbody>
<tr><td>index</td><td>uint32</td><td>4</td><td>Start index into the map's key/value arrays.</td></tr>
<tr><td>count</td><td>uint32</td><td>4</td><td>Number of entries in this bucket. (linear probe range)</td></tr>
</tbody></table>
</div>
<p>See <a href="game/kfc/file.html#static-map">Static Map</a> for details.</p>
<h3 id="contenthash"><a class="header" href="#contenthash">ContentHash</a></h3>
<p>A content hash is used to reference content assets within <code>.dat</code> files.</p>
<p>Here is how it is structured:</p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Size (bytes)</th><th>Description</th></tr></thead><tbody>
<tr><td>size</td><td>uint32</td><td>4</td><td>The size of the content.</td></tr>
<tr><td>hash0</td><td>uint32</td><td>4</td><td>First part of the hash.</td></tr>
<tr><td>hash1</td><td>uint32</td><td>4</td><td>Second part of the hash.</td></tr>
<tr><td>hash2</td><td>uint32</td><td>4</td><td>Third part of the hash.</td></tr>
</tbody></table>
</div>
<p>The hash of the content is computed with a <a href="https://github.com/Brabb3l/kfc-parser/blob/a7f4e26f33644316664646cd4cb6f1f21a223eb7/crates/kfc-base/src/hash/content.rs">custom algorithm</a> which produces a 128-bit hash.
The first 4 bytes of the result is then replaced with the size of the content.</p>
<p>The <code>size</code> field is used for determining the size of the content and there is no other way to get it.</p>
<p>Since content with the same data have the same <code>ContentHash</code>, you don't need to store the same content multiple times.</p>
<h3 id="contententry"><a class="header" href="#contententry">ContentEntry</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Size (bytes)</th><th>Description</th></tr></thead><tbody>
<tr><td>offset</td><td>uint32</td><td>4</td><td>Offset inside the referenced <code>.dat</code> file where the content starts.</td></tr>
<tr><td>flags</td><td>uint16</td><td>2</td><td>Currently unused, always 0.</td></tr>
<tr><td>container_index</td><td>uint16</td><td>2</td><td>Index into the containers array.</td></tr>
<tr><td>padding</td><td>uint8[8]</td><td>8</td><td>Padding to make the struct 16 bytes long. Always 0.</td></tr>
</tbody></table>
</div>
<p>Content is always aligned to <strong>4096 bytes</strong> inside the <code>.dat</code> files.
The size of the content is not stored here, but in the <a href="game/kfc/file.html#contenthash">ContentHash</a>.</p>
<h3 id="resourceid"><a class="header" href="#resourceid">ResourceId</a></h3>
<p>A resource ID is used to reference resources within the <code>.kfc</code> file.
It is a completely unique identifier for each resource.
Here is how it is structured:</p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Size (bytes)</th><th>Description</th></tr></thead><tbody>
<tr><td>hash</td><td>uint32[4]</td><td>16</td><td>The hash of the resource.</td></tr>
<tr><td>type_hash</td><td>uint32</td><td>4</td><td>The qualified hash of the resource type.</td></tr>
<tr><td>part_index</td><td>uint32</td><td>4</td><td>The index of the part if there are multiple instances of this resource.</td></tr>
<tr><td>reserved0</td><td>uint32</td><td>4</td><td>Reserved, always 0.</td></tr>
<tr><td>reserved1</td><td>uint32</td><td>4</td><td>Reserved, always 0.</td></tr>
</tbody></table>
</div>
<p>The hash of the resource id is a randomly generated UUIDv4.</p>
<h3 id="resourceentry"><a class="header" href="#resourceentry">ResourceEntry</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Size (bytes)</th><th>Description</th></tr></thead><tbody>
<tr><td>offset</td><td>uint32</td><td>4</td><td>Offset inside the resource location where the resource starts.</td></tr>
<tr><td>size</td><td>uint32</td><td>4</td><td>Size of the resource in bytes.</td></tr>
</tbody></table>
</div>
<p>The absolute offset of the resource can be calculated by adding the <code>offset</code> to the <code>offset</code> of the <a href="game/kfc/file.html#resourcelocation">ResourceLocation</a>.</p>
<h3 id="resourcebundleentry"><a class="header" href="#resourcebundleentry">ResourceBundleEntry</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Size (bytes)</th><th>Description</th></tr></thead><tbody>
<tr><td>internal_hash</td><td>uint32</td><td>4</td><td>The internal hash of the resource type.</td></tr>
<tr><td>index</td><td>uint32</td><td>4</td><td>Index into the <code>resource_keys</code> array.</td></tr>
<tr><td>count</td><td>uint32</td><td>4</td><td>Number of resources of this type.</td></tr>
</tbody></table>
</div>
<h2 id="static-map"><a class="header" href="#static-map">Static Map</a></h2>
<p>Static maps consists of three arrays: buckets, keys and values.
There are always <code>N</code> buckets, where <code>N</code> is a power of two, and the key and value arrays must always have the same length.</p>
<p>Here is how to look up a key in a static map in pseudocode:</p>
<pre><code class="language-pseudo">hash = hash_function(key) % buckets.count
bucket = buckets[hash]

for i in 0 until bucket.count:
    idx = bucket.index + i

    if keys[idx] == key:
        return values[idx]

return not_found
</code></pre>
<h3 id="hash-functions"><a class="header" href="#hash-functions">Hash Functions</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Key Type</th><th>Hash Function</th></tr></thead><tbody>
<tr><td>ContentHash</td><td><code>hash0</code> field of the <code>ContentHash</code> (precomputed)</td></tr>
<tr><td>ResourceId</td><td>A seeded <a href="game/kfc/file.html#fnv-1a32">FNV-1a32</a> over a 64-bit word formed from <code>type_hash</code> (low 32 bits) and <code>part_index</code> (high 32 bits) with <code>hash[0]</code> as the seed.</td></tr>
<tr><td>uint32</td><td>The uint32 value itself.</td></tr>
</tbody></table>
</div>
<p><strong>Note:</strong> The 64-bit word <code>data = type_hash | (part_index &lt;&lt; 32)</code> is serialized in little-endian byte order and then fed, byte-by-byte, into FNV-1a32.</p>
<h3 id="fnv-1a32"><a class="header" href="#fnv-1a32">FNV-1a32</a></h3>
<p>See <a href="https://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function">FNV hash on Wikipedia</a>.</p>
<p>Here is the pseudocode for FNV-1a32 used by the game:</p>
<pre><code class="language-pseudo">function fnv1a32(data: byte[]) -&gt; uint32:
    return fnv1a32_with_seed(data, 0x811C9DC5)

function fnv1a32_with_seed(data: byte[], seed: uint32) -&gt; uint32:
    hash = seed

    for byte in data:
        hash = hash XOR byte
        hash = hash * 0x01000193

    return hash
</code></pre>
<h2 id="resource-bundles"><a class="header" href="#resource-bundles">Resource Bundles</a></h2>
<p>Resource bundles are a collection of resources of the same type.
You can use them to efficiently look up all resources of a specific type.</p>
<p>Here is how to get all resources of a specific type in pseudocode:</p>
<pre><code class="language-pseudo">bundle = resource_bundles.get(type_hash)
bundle_resources = []

for i in 0 until bundle.count:
    idx = bundle.index + i

    resource_index = resource_indices[idx]
    resource_id = resource_keys[resource_index]
    resource_entry = resource_values[resource_index]

    bundle_resources.append((resource_id, resource_entry))

return bundle_resources
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="resource-format-specification"><a class="header" href="#resource-format-specification">Resource Format Specification</a></h1>
<p>This document describes the format of <strong>resources</strong> stored inside the <code>.kfc</code> file.</p>
<p>Resources are typed binary objects. The concrete structure of types (fields, type hashes, field offsets, alignments, etc.) is defined in the <a href="game/kfc/./types.html">types section</a>.</p>
<h2 id="general-notes"><a class="header" href="#general-notes">General Notes</a></h2>
<ul>
<li>Everything is little-endian unless otherwise noted.</li>
<li>Make sure to zero out any padding bytes when serializing.</li>
</ul>
<h2 id="primitive-types"><a class="header" href="#primitive-types">Primitive Types</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Ordinal</th><th>Description</th></tr></thead><tbody>
<tr><td><code>none</code></td><td><code>0x00</code></td><td>No data</td></tr>
<tr><td><code>bool</code></td><td><code>0x01</code></td><td>1 byte, values: <code>0x00</code> (false), <code>0x01</code> (true)</td></tr>
<tr><td><code>uint8</code></td><td><code>0x02</code></td><td>1 byte unsigned integer</td></tr>
<tr><td><code>sint8</code></td><td><code>0x03</code></td><td>1 byte signed integer</td></tr>
<tr><td><code>uint16</code></td><td><code>0x04</code></td><td>2 byte unsigned integer</td></tr>
<tr><td><code>sint16</code></td><td><code>0x05</code></td><td>2 byte signed integer</td></tr>
<tr><td><code>uint32</code></td><td><code>0x06</code></td><td>4 byte unsigned integer</td></tr>
<tr><td><code>sint32</code></td><td><code>0x07</code></td><td>4 byte signed integer</td></tr>
<tr><td><code>uint64</code></td><td><code>0x08</code></td><td>8 byte unsigned integer</td></tr>
<tr><td><code>sint64</code></td><td><code>0x09</code></td><td>8 byte signed integer</td></tr>
<tr><td><code>float32</code></td><td><code>0x0A</code></td><td>4 byte IEEE 754 floating point number</td></tr>
<tr><td><code>float64</code></td><td><code>0x0B</code></td><td>8 byte IEEE 754 floating point number</td></tr>
<tr><td><code>enum</code></td><td><code>0x0C</code></td><td>stored using the enum's <code>inner_type</code> (see <a href="game/kfc/resource.html#enum">Enum</a>)</td></tr>
<tr><td><code>bitmask8</code></td><td><code>0x0D</code></td><td>1 byte bitmask (up to 8 flags)</td></tr>
<tr><td><code>bitmask16</code></td><td><code>0x0E</code></td><td>2 byte bitmask (up to 16 flags)</td></tr>
<tr><td><code>bitmask32</code></td><td><code>0x0F</code></td><td>4 byte bitmask (up to 32 flags)</td></tr>
<tr><td><code>bitmask64</code></td><td><code>0x10</code></td><td>8 byte bitmask (up to 64 flags)</td></tr>
<tr><td><code>typedef</code></td><td><code>0x11</code></td><td>stored using the typedef's <code>inner_type</code> (see <a href="game/kfc/resource.html#typedef">Typedef</a>)</td></tr>
<tr><td><code>struct</code></td><td><code>0x12</code></td><td>see <a href="game/kfc/resource.html#struct">Struct</a></td></tr>
<tr><td><code>static_array</code></td><td><code>0x13</code></td><td>a fixed-size array (see <a href="game/kfc/resource.html#static-array">Static Array</a>)</td></tr>
<tr><td><code>ds_array</code></td><td><code>0x14</code></td><td>unknown/not used</td></tr>
<tr><td><code>ds_string</code></td><td><code>0x15</code></td><td>unknown/not used</td></tr>
<tr><td><code>ds_optional</code></td><td><code>0x16</code></td><td>unknown/not used</td></tr>
<tr><td><code>ds_variant</code></td><td><code>0x17</code></td><td>unknown/not used</td></tr>
<tr><td><code>blob_array</code></td><td><code>0x18</code></td><td>a variable-size array (see <a href="game/kfc/resource.html#blob-array">Blob Array</a>)</td></tr>
<tr><td><code>blob_string</code></td><td><code>0x19</code></td><td>a variable-size string (see <a href="game/kfc/resource.html#blob-string">Blob String</a>)</td></tr>
<tr><td><code>blob_optional</code></td><td><code>0x1A</code></td><td>an optional value (see <a href="game/kfc/resource.html#blob-optional">Blob Optional</a>)</td></tr>
<tr><td><code>blob_variant</code></td><td><code>0x1B</code></td><td>a variant of the base type (see <a href="game/kfc/resource.html#blob-variant">Blob Variant</a>)</td></tr>
<tr><td><code>object_reference</code></td><td><code>0x1C</code></td><td>16 byte GUID referencing another resource</td></tr>
<tr><td><code>guid</code></td><td><code>0x1D</code></td><td>16 byte ContentHash</td></tr>
</tbody></table>
</div>
<h3 id="enum"><a class="header" href="#enum">Enum</a></h3>
<ul>
<li>An <code>enum</code> is stored using its <code>inner_type</code> (in the type metadata).</li>
<li>The <code>inner_type</code> is always a primitive integer type (<code>uint8</code>, <code>sint8</code>, <code>uint16</code>, <code>sint16</code>, <code>uint32</code>, <code>sint32</code>, <code>uint64</code>, <code>sint64</code>).</li>
</ul>
<h3 id="struct"><a class="header" href="#struct">Struct</a></h3>
<ul>
<li>A <code>struct</code> is a composite type consisting of multiple fields which is essentially a concatenation of its fields' serialized bytes.</li>
<li>If a struct inherits from a base struct (namely, has a <code>inner_type</code>), the base struct's fields are serialized <strong>first</strong> (parents recursively up the chain).</li>
<li>Each field is serialized <strong>without its keys</strong>, just its value.</li>
</ul>
<p><strong>Note:</strong> Each field has a <code>field_offset</code> in the type metadata which can be used to locate the field's value inside the struct instead of recomputing padding/alignment yourself.</p>
<h3 id="typedef"><a class="header" href="#typedef">Typedef</a></h3>
<ul>
<li>A <code>typedef</code> is an alias for another type (the <code>inner_type</code>).</li>
<li>It can be resolved by simply serializing the <code>inner_type</code> recursively until a non-typedef type is reached.</li>
</ul>
<h3 id="static-array"><a class="header" href="#static-array">Static Array</a></h3>
<ul>
<li>A <code>static_array</code> is a fixed-size array of elements of the same type.</li>
<li>The number of elements is <code>field_count</code> (in the type metadata).</li>
<li>The element type is <code>inner_type</code> (in the type metadata).</li>
<li>Elements are stored contiguously, directly inline.</li>
</ul>
<h3 id="blob-array"><a class="header" href="#blob-array">Blob Array</a></h3>
<ul>
<li>Out-of-line, data is stored as a blob.</li>
<li>Layout:
<ul>
<li>4 byte <code>uint32</code> relative offset (0 if empty)</li>
<li>4 byte <code>uint32</code> count (0 if empty)</li>
</ul>
</li>
<li>The element type is <code>inner_type</code> (in the type metadata).</li>
<li>Elements are stored contiguously, at the given blob offset.</li>
<li><strong>IMPORTANT:</strong> blob rules apply, see <a href="game/kfc/resource.html#blob-rules">Blob Rules</a>.</li>
</ul>
<h3 id="blob-string"><a class="header" href="#blob-string">Blob String</a></h3>
<ul>
<li>Out-of-line, data is stored as a blob (non-null-terminated).</li>
<li>Layout:
<ul>
<li>4 byte <code>uint32</code> relative offset (0 if empty)</li>
<li>4 byte <code>uint32</code> length in bytes (0 if empty)</li>
</ul>
</li>
<li>Characters are stored as bytes at the given blob offset.</li>
<li><strong>IMPORTANT:</strong> blob rules apply, see <a href="game/kfc/resource.html#blob-rules">Blob Rules</a>.</li>
</ul>
<h3 id="blob-optional"><a class="header" href="#blob-optional">Blob Optional</a></h3>
<ul>
<li>Out-of-line, data is stored as a blob.</li>
<li>Layout:
<ul>
<li>4 byte <code>uint32</code> relative offset (0 if null)</li>
</ul>
</li>
<li>The inner type is <code>inner_type</code> (in the type metadata).</li>
<li>The value is stored at the given blob offset if not null.</li>
<li><strong>IMPORTANT:</strong> blob rules apply, see <a href="game/kfc/resource.html#blob-rules">Blob Rules</a>.</li>
</ul>
<h3 id="blob-variant"><a class="header" href="#blob-variant">Blob Variant</a></h3>
<ul>
<li>Out-of-line, data is stored as a blob.</li>
<li>Layout:
<ul>
<li>4 byte <code>uint32</code> qualified type hash of the stored variant (0 if no variant is specified)</li>
<li>4 byte <code>uint32</code> relative offset (0 if no variant is specified)</li>
<li>4 byte <code>uint32</code> blob size in bytes (0 if no variant is specified)</li>
</ul>
</li>
<li>The base type is <code>inner_type</code> (in the type metadata).</li>
<li><strong>IMPORTANT:</strong> blob rules apply, see <a href="game/kfc/resource.html#blob-rules">Blob Rules</a>.</li>
</ul>
<h2 id="blob-rules"><a class="header" href="#blob-rules">Blob Rules</a></h2>
<p>Blob types (<code>blob_array</code>, <code>blob_string</code>, <code>blob_optional</code>, <code>blob_variant</code>) are placed <strong>out-of-line</strong> after the fixed-size base struct.
They need to be properly spaced and aligned according to their type metadata.</p>
<p>Because of this, when <strong>serializing</strong> a blob value you must manage this process yourself.
Feel free to implement this in a way that makes sense for you, but here is how the game seems to do it:</p>
<ol>
<li>Set a <code>blob_offset</code> to the size of the base struct.</li>
<li>Serialize everything <strong>in order</strong>. For each blob field, do the following:
<ul>
<li><strong>(BlobVariant only)</strong> Write the qualified type hash.</li>
<li><strong>Align <code>blob_offset</code></strong> to the blob data's alignment specified by the type metadata for the blob's data.</li>
<li>Compute <code>relative_offset = blob_offset - stream.position</code>, where:
<ul>
<li><code>stream.position</code> is the absolute position of the <code>relative_offset</code> field itself.
(i.e. the position where the <code>relative_offset</code> will be written)</li>
</ul>
</li>
<li>Write the <code>relative_offset</code>.</li>
<li>Write the <code>count</code>/<code>length</code>/<code>size</code> field if applicable. (<code>blob_array</code>, <code>blob_string</code>, <code>blob_variant</code>)</li>
<li>Then write the <strong>blob data</strong> at the current <code>blob_offset</code>.</li>
<li>After writing the blob data, increment <code>blob_offset</code> by the size of the written blob data.</li>
<li>And finally <strong>align <code>blob_offset</code> again</strong> to the blob data's alignment.</li>
</ul>
</li>
<li>Continue with the next field until all fields are serialized.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="types-1"><a class="header" href="#types-1">Types</a></h1>
<p>WIP :(</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="kfc-parser-deprecated"><a class="header" href="#kfc-parser-deprecated">kfc-parser (deprecated)</a></h1>
<p><strong>This project has been deprecated and will no longer receive additional features but will (for the foreseeable future) continue to receive bug fixes.</strong></p>
<p>The kfc-parser is a command-line interface (CLI) for working with the <strong><code>.kfc</code></strong> format used by Enshrouded.
It allows users to unpack, repack, and restore game files, as well as disassemble and assemble impact programs.</p>
<h2 id="usage"><a class="header" href="#usage">Usage</a></h2>
<h3 id="unpacking-and-repacking"><a class="header" href="#unpacking-and-repacking">Unpacking and Repacking</a></h3>
<p>To unpack game files, use the <code>unpack</code> command.</p>
<pre><code class="language-sh">kfc-parser.exe unpack -g &lt;game-dir&gt; -o &lt;output-dir&gt; [OPTIONS]
</code></pre>
<p>To repack unpacked files, use the <code>repack</code> command.</p>
<p>It will repack all <code>.json</code> files in the input directory which have a
qualified guid name (e.g. <code>82706b40-61b1-4b8f-8b23-dcec6971bda1_9398e747_0.json</code>).
The hash between the two underscores (<code>9398e747</code> in this case) is used to determine the file type.</p>
<pre><code class="language-sh">kfc-parser.exe repack -g &lt;game-dir&gt; -i &lt;input-dir&gt; [OPTIONS]
</code></pre>
<h3 id="restoring-original-game-files"><a class="header" href="#restoring-original-game-files">Restoring Original Game Files</a></h3>
<p>To restore the original game files, use the <code>restore</code> command.</p>
<pre><code class="language-sh">kfc-parser.exe restore -g &lt;game-dir&gt;
</code></pre>
<h3 id="impact-cli"><a class="header" href="#impact-cli">Impact CLI</a></h3>
<p>The <code>impact</code> sub command can be used to convert an impact program into
a more manageable format and vice versa.</p>
<p>The <code>disassemble</code> command will convert an impact program into a <code>.impact</code> and <code>.shutdown.impact</code>
file which will contain the program's bytecode in text format and a <code>.data.json</code> file which will
contain the program's data such as variables, etc.</p>
<pre><code class="language-sh">kfc-parser.exe impact disassemble -i &lt;input-file-name&gt;
</code></pre>
<p>To convert the disassembled files back into an impact program, use the <code>assemble</code> command.</p>
<p>The <code>input-file-name</code> should be the shared name of the disassembled files as follows:</p>
<ul>
<li><code>&lt;input-file-name&gt;.impact</code></li>
<li><code>&lt;input-file-name&gt;.shutdown.impact</code></li>
<li><code>&lt;input-file-name&gt;.data.json</code></li>
</ul>
<pre><code class="language-sh">kfc-parser.exe impact assemble -i &lt;input-file-name&gt; [OPTIONS]
</code></pre>
<h3 id="extracting-reflection-data"><a class="header" href="#extracting-reflection-data">Extracting Reflection Data</a></h3>
<p>To extract reflection data from the enshrouded executable, use the <code>extract-types</code> command.</p>
<p><strong>Note:</strong> This is automatically executed when unpacking or repacking files.</p>
<pre><code class="language-sh">kfc-parser.exe extract-types [OPTIONS]
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>


    </div>
    </body>
</html>
